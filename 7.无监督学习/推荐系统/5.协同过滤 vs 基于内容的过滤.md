# 协同过滤 `vs` 基于内容的过滤

## 1.简单比较

- **协同过滤**：
  - 使用协同过滤，一般方法是根据与我们给出相似评分的用户来推荐项目
- **基于内容的过滤**：
  - 基于内容的过滤会根据用户的特征和物品的特征来推荐物品，以找到合适的匹配项；换句话说，它需要每个用户的一些特征，以及每个用户的一些特征，它使用这些特征来尝试决定哪些项目和用户可能彼此匹配；
  - 使用基于内容的过滤算法，仍然会使用用户对某些项目进行评分的数据，但基于内容的过滤的关键在于，它能够充分地利用用户和项目的特征来找到比纯粹的协同过滤方法可能更好的匹配；



## 2. **基于内容的过滤的工作方式演示**

<img src="C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20240116110203206.png" alt="image-20240116110203206" style="zoom:67%;" />

假设我们有以上关于用户的特征向量 $x_u^{(j)}$ 和 关于电影的特征向量 $x_m^{(i)}$，在给定这些特征之后，**基于内容的过滤** 的任务是**试图弄清楚给定的电影$i$ 是否会与用户$j$ 很好地匹配**。

**注意**：关于用户的特征向量$x_u^{(j)}$ 和 关于电影的特征向量$x_m^{(i)}$ 的大小（维度）不需要保持一致，即使相差较大也没有关系。

在**基于内容的过滤**中，我们将开发一种算法来学习匹配用户和电影：

- 在**协同过滤**中，我们预测用户$j$ 对电影$i$ 的评分为： $\mathbf{w}^{(j)}·\mathbf{x}^{(i)}+b^{(j)}$
- 但是在**基于内容的过滤** 中：
  - 我们不需要 $b^{(j)}$，即将 $b^{(j)}$ 去除
  - 将 $\mathbf{w}^{(j)}$ 替换为 $\mathbf{v}_u^{(j)}$（$\mathbf{v}_u^{(j)}$ 是根据用户$j$ 的特征向量$\mathbf{x}_u^{(j)}$计算出来的向量）
  - $\mathbf{x}^{(i)}$ 替换为 $\mathbf{v}_m^{(j)}$（$\mathbf{v}_m^{(i)}$ 是根据电影$i$ 的特征向量$\mathbf{x}_m^{(i)}$ 计算出来的向量）
  - 则预测用户$j$ 对电影$i$ 的评分为：$\mathbf{v}_u^{(j)}·\mathbf{v}_m^{(i)}$
  - 如果我们可以对向量$\mathbf{v}_u^{(j)}$ 和向量$\mathbf{v}_m^{(i)}$ 做出适当的选择，则可以希望这两个向量之间的点击能够很好地预测用户$j$对电影$i$ 的评分
  - **注意**：虽然用户的特征向量$\mathbf{x}_u^{(j)}$ 和电影的特征向量$\mathbf{x}_m^{(i)}$ 的大小可以不同，但是从用户和电影的特征向量学习得到的向量 $\mathbf{v}_u^{(j)}$ 和$\mathbf{v}_m^{(i)}$ 的大小必须相同，因为我们需要它们之间进行点积运算。

例如，通过学习：

- 从用户的特征向量中学习得到了用户对各种电影的偏好$\mathbf{v}_u^{(j)}$
- 从电影的特征向量中学习得到了电影在各种类型的价值$\mathbf{v}_m^{(i)}$

<img src="C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20240116112024504.png" alt="image-20240116112024504" style="zoom:67%;" />

则通过这两个向量的点积运算，然后求和，以希望预测得到该特定用户对这部电影的喜爱程度（评分）。



## 3.使用深度学习开发基于内容的过滤算法

在**基于内容的过滤算法**中，对于给定的用户的特征向量$\mathbf{x}_u^{(j)}$，需要从中学习计算得到向量 $\mathbf{v}_u^{(j)}$，同时对于给定的电影的特征向量$\mathbf{x}_m^{(i)}$，需要从中学习计算得到向量$\mathbf{v}_m^{(i)}$。为了实现这两个所需向量的计算，我们可以构建两个不同的神经网络来分别对用户的特征向量和电影的特征向量学习：

- 用户神经网络：从用户的特征向量中学习得到 $\mathbf{v}_u^{(j)}$
- 电影神经网络：从电影的特征向量中学习得到 $\mathbf{v}_m^{(i)}$
- 最后，通过这两个向量$\mathbf{v}_u^{(j)}$和$\mathbf{v}_m^{(i)}$的点积$\mathbf{v}_u^{(j)}·\mathbf{v}_m^{(i)}$，来预测用户$j$对电影$i$的评分

<img src="C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20240116112956852.png" alt="image-20240116112956852" style="zoom:67%;" />

**注意**：用于用户的神经网络和用于电影的神经网络可以具有不同数量的隐藏层以及每个隐藏层可以含有不同数量的单元，但最后的输出层必须具有相同的单元（因为要求这两个向量$\mathbf{v}_u^{(j)}$和$\mathbf{v}_m^{(i)}$的大小必须相同）。

同样的，如果我们想要预测的不是评分（一个实数），而是一个二进制标签（喜欢/不喜欢），则可以修改模型最后的预测以输出概率值$p(y^{(i,j)}=1)$，即将模型的预测修改为 $sigmod(\mathbf{v}_u^{(j)}·\mathbf{v}_m^{(i)})$。



在上述描述中，我们需要构建两个神经网络（不一定相同），分别用于从用户的特征向量中学习和从电影的特征向量中学习，并且我们将它们分开构建，但实际上，我们可以将其构建在同一个系统中：

![image-20240116113735001](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20240116113735001.png)

如上图所示，现在，这个模型有很多的参数，神经网络的每一层都有一组参数，为了训练用户网络和电影网络的所有参数，我们需要构建一个成本函数 $J$，它与协同过滤中看到的成本函数非常相似：假设我们有一些用户对某些电影进行评分的数据，则我们将对所有有标签的项目的预测求误差的平方并进行累加（即预测误差的平方总和）：
$$
J=\sum_{(i,j):r(i,j)=1} (\mathbf{v}_u^{(j)}·\mathbf{v}_m^{(i)}-y^{(i,j)})^2 + NN \space regularization \space term
$$
需要明确的是，用户和电影网络没有单独的训练程序，上述的成本函数是用于训练用户和电影网络的所有参数的成本函数。

我们将根据学习得到的这两个向量$\mathbf{v}_u^{(j)}$和$\mathbf{v}_m^{(i)}$ 能否很好地预测评分$y^{(i,j)}$ 来评估这个模型（两个网络）的好坏，并使用这个成本函数，以及使用梯度下降或其他优化算法来调整网络的参数以使成本函数$J$ 的值尽可能小。

如果想要对这个模型进行正则化，则还可以添加常用的神经网络正则化项，使得参数尽可能小以避免该模型过拟合。



在训练了这个模型之后，我们也可以用它来寻找相似的物品：

- $\mathbf{v}_u^{(j)}$ 是一个32位长的向量，且描述了具有特征 $\mathbf{x}_u^{(j)}$ 的用户$j$
- $\mathbf{v}_m^{(i)}$ 是一个32位长的向量，且描述了具有特征 $\mathbf{x}_m^{(i)}$ 的电影$i$

如果我们想要找到与电影$i$ 相似的其他电影，则我们可以寻找其他电影$k$ 使得描述电影$k$的向量$\mathbf{v}_m^{(k)}$ 与描述电影$i$ 的向量$\mathbf{v}_m^{(i)}$ 之间的距离很小（很接近），即保证 $||\mathbf{v}_m^{(k)}-\mathbf{v}_m^{(i)}||^2$很小。

在实际项目中，这是可以提前计算的，我们可以在一夜之间运行一个计算服务器来遍历所有电影，并未每部电影找到与之相似的电影，第二天如果用户访问该网站并且他们正在浏览特定的电影，则可以将已经预先计算出来的10或20部最相似的电影展示给当时的用户。



## 4. 从大型目录中推荐

今天的推荐系统有时候需要从数千或数百万或数千万甚至更多的目录中挑选出少量物品进行推荐。

大规模的推荐系统的实现分为两个步骤：

1. **检索**：
   1. 生成大量的候选项目；例如：
      1. 对于每部用户曾经看过的电影，至少找10部与之相似的电影；
      2. 对于观看最多的3种类型，找到排名前10的电影；
      3. 排名前20的电影；
   2. 将检索到的所有项目合并，去除重复或者已经观看、购买的项目；
2. **排名**：
   1. 获取在检索步骤得到的列表，并使用学习模型对它们进行排名；
      - 即可以将用户的特征向量和候选列表中的电影的特征向量输入模型，并为每个用户电影对电影的评分进行预测；
   2. 展示经过排名的项目给用户；



**检索步骤**：

1. 在检索步骤检索更多的项目将会提升推荐的性能，但是会降低推荐的速度；
2. 为了分析/优化权衡，建议进行离线实现，看看检索多少额外项目会产生更相关的推荐（即推荐的项目 $p(y^{(i,j)}=1)$概率值更高，即更受用户喜欢）